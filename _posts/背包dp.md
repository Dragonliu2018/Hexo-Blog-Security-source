---
title: 背包dp
tags:
categories:
  - 09-算法
toc: true
mathjax: true
top: false
comments: true
copyright: true
date: 2022-04-19 13:29:39
---

> 转载：[dd大牛的《背包九讲》](https://www.cnblogs.com/jbelial/articles/2116074.html)、[背包问题九讲](https://www.kancloud.cn/kancloud/pack/70124)、[知乎转载](https://zhuanlan.zhihu.com/p/139368825)

# P01: 01背包

## 题目

有N件物品和一个容量为V的背包。第i件物品的费用/体积是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。

## 基本思路

这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。

用子问题定义状态：即$f[i][v]$表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：$f[i][v]=max\{f[i-1][v],f[i-1][v-c[i]]+w[i]\}$。

这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是$f [i-1][v-c[i]]$再加上通过放入第i件物品获得的价值$w[i]$。

注意$f[i][v]$有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是$f[N] [V]$，而是$f[N][0...V]$的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项$f[i][v-1]$，这样就可以保证$f[N] [V]$就是最后的答案。

## 优化——空间复杂度

以上方法的时间和空间复杂度均为$O(N*V)$，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到$O(V)$。

先考虑上面讲的基本思路如何实现，肯定是有一个主循环$i=1...N$，每次算出来二维数组$f[i][0..V]$的所有值。那么，如果只用一个数组$f [0..V]$，能不能保证第$i$次循环结束后$f[v]$中表示的就是我们定义的状态$f[i][v]$呢？$f[i][v]$是由$f[i-1][v]$和$f[i-1] [v-c[i]]$两个子问题递推而来，能否保证在推$f[i][v]$时（也即在第$i$次主循环中推$f[v]$时）能够得到$f[i-1][v]$和$f[i-1][v -c[i]]$的值呢？事实上，这要求在每次主循环中我们以$v=V..0$的顺序推$f[v]$，这样才能保证推$f[v]$时$f[v-c[i]]$保存的是状态$f[i -1][v-c[i]]$的值。伪代码如下：

```C++
for i=1..N
	for v=V..0
		f[v]=max{f[v],f[v-c[i]]+w[i]};
```

其中的$f[v]=max\{f[v],f[v-c[i]]+w[i]\}$一句恰就相当于我们的转移方程$f[i][v]=max\{f[i-1][v],f[i- 1][v-c[i]]+w[i]\}$，因为现在的$f[v-c[i]]$就相当于原来的$f[i-1][v-c[i]]$。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了$f[i][v]$由$f[i][v-c[i]]$推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。

## 代码实现

```C++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 5;//物品最大数量
const int maxv = 1e3 + 5;//背包最大体积

int dp[maxv];//背包
int volume[maxn], value[maxn];//每个物品的体积和价值
int n, v;//总物品数、背包体积
//01背包 每种物品仅有一件，可以选择放或不放
void zero_one_park(int val, int vol) {
    for (int j = v; j >= vol; j--) {
        dp[j] = max(dp[j], dp[j - vol] + val);
    }
}
int main() {
    cin>> n>> v;
    for (int i = 1; i <= n; i++) {
        cin>> volume[i]>> value[i];
    }
    for (int i = 1; i <= n; i++) {
        zero_one_park(value[i], volume[i]);
    }
    cout<< dp[v]<< endl;
    return 0;
}
```

## 小结

01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。

## 练习

1. [acwing模板题——01背包问题](https://www.acwing.com/problem/content/2/)

# P02: 完全背包问题

## 题目

有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

## 基本思路

这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：$f[i][v]=max\{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<= v\}$。这跟01背包问题一样有$O(N*V)$个状态需要求解，但求解每个状态的时间则不是常数了，求解状态$f[i][v]$的时间是$O(v/c[i])$，总的复杂度是超过$O(VN)$的。

将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。

## 优化

### 一个简单有效的优化

完全背包问题有一个很简单有效的优化，是这样的：若两件物品$i、j$满足$c[i]<=c[j]$且$w[i]>=w[j]$，则将物品$j$去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高的$j$换成物美价廉的$i$，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。

### 转化为01背包问题求解

既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选$V/c [i]$件，于是可以把第$i$种物品转化为$V/c[i]$件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。

更高效的转化方法是：把第i种物品拆成费用为$c[i]*2^k$、价值为$w[i]*2^k$的若干件物品，其中$k$满足$c[i]*2^k<V$。这是二进制的思想，因为不管最优策略选几件第$i$种物品，总可以表示成若干个$2^k$件物品的和。这样把每种物品拆成$O(log(V/c[i]))$件物品，是一个很大的改进。但我们有更优的$O(VN)$的算法。 

### $O(VN)$的算法

这个算法使用一维数组，先看伪代码：

```c++
for i=1..N 
    for v=0..V 
        f[v]=max{f[v],f[v-c[i]]+w[i]};
```

你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照$v=V..0$的逆序来循环。这是因为要保证第$i$次循环中的状态$f[i][v]$是由状态$f[i-1][v-c[i]]$递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第$i$件物品”这件策略时，依据的是一个绝无已经选入第$i$件物品的子结果$f[i-1][v-c[i]]$。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第$i$种物品”这种策略时，却正需要一个可能已选入第$i$种物品的子结果$f[i][v-c[i]]$，所以就可以并且必须采用$v= 0..V$的顺序循环。这就是这个简单的程序为何成立的道理。

这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：$f[i][v]=max\{f[i-1][v],f[i][v-c[i]]+w[i]\}$，将这个方程用一维数组实现，便得到了上面的伪代码。

## 代码实现

```C++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 5;//物品最大数量
const int maxv = 1e3 + 5;//背包最大体积

int dp[maxv];//背包
int volume[maxn], value[maxn];//每个物品的体积和价值
int n, v;//总物品数、背包体积
//完全背包 每种物品都有无限件可用
void complete_park(int val, int vol) {
    for (int j = vol; j <= v; j++) {
        dp[j] = max(dp[j], dp[j - vol] + val);
    }
}
int main() {
    cin>> n>> v;
    for (int i = 1; i <= n; i++) {
        cin>> volume[i]>> value[i];
    }
    for (int i = 1; i <= n; i++) {
        complete_park(value[i], volume[i]);
    }
    cout<< dp[v]<< endl;
    return 0;
}
```

## 小结

完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。

## 练习

1. [acwing模板题——完全背包问题](https://www.acwing.com/problem/content/3/)

# P03: 多重背包问题

## 题目

有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

## 基本思路

这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第$i$种物品有$n[i]+1$种策略：取0件，取1件……取 $n[i]$件。令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大权值，则：$f[i][v]=max\{f[i-1][v-k*c[i]]+ k*w[i]|0<=k<=n[i]\}$。复杂度是$O(V*∑n[i])$。

## 优化

### 转化为01背包问题

另一种好想好写的基本方法是转化为01背包求解：把第$i$种物品换成$n[i]$件01背包中的物品，则得到了物品数为$∑n[i]$的01背包问题，直接求解，复杂度仍然是$O(V*∑n[i])$。

但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第$i$种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取$0..n[i]$件——均能等价于取若干件代换以后的物品。另外，取超过$n[i]$件的策略必不能出现。

方法是：将第$i$种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 $1,2,4,...,2^{k-1},n[i]-2^k+1$，且$k$是满足$n[i]-2^k+1>0$的最大整数。例如，如果$n[i]$为$13$，就将这种物品分成系数分别为$1,2,4,6$的四件物品。

分成的这几件物品的系数和为$n[i]$，表明不可能取多于$n[i]$件的第i种物品。另外这种方法也能保证对于$0..n[i]$间的每一个整数，均可以用若干个系数的和表示，这个证明可以分$0..2^{k-1}$和$2^k..n[i]$两段来分别讨论得出，并不难，希望你自己思考尝试一下。

这样就将第$i$种物品分成了$O(log n[i])$种物品，将原问题转化为了复杂度为$O(V*∑log n[i])$的01背包问题，是很大的改进。

### * $O(VN)$的算法

多重背包问题同样有$O(VN)$的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊$O(1)$的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。

## 代码实现

```C++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 5;//物品最大数量
const int maxv = 1e3 + 5;//背包最大体积

int dp[maxv];//背包
int volume[maxn], value[maxn], c[maxn];//每个物品的体积和价值、数量
int n, v;//总物品数、背包体积
//01背包 每种物品仅有一件，可以选择放或不放
void zero_one_park(int val, int vol) {
    for (int j = v; j >= vol; j--) {
        dp[j] = max(dp[j], dp[j - vol] + val);
    }
}
//完全背包 每种物品都有无限件可用
void complete_park(int val, int vol) {
    for (int j = vol; j <= v; j++) {
        dp[j] = max(dp[j], dp[j - vol] + val);
    }
}
//多重背包 每种物品都有限件可用
void multiple_park(int val, int vol, int amount) {
    if (vol * amount >= v) {//该种物品足以装满背包，转化为完全背包
        complete_park(val, vol);
    } else {//转化为01背包，将第i种物品分成若干件物品
        int k = 1;
        while (k < amount) {
            zero_one_park(k * val, k * vol);
            amount -= k;
            k <<= 1;
        }
        if (amount > 0) {
            zero_one_park(amount * val, amount * vol);
        }
    }
}
int main() {
    cin>> n>> v;
    for (int i = 1; i <= n; i++) {
        cin>> volume[i]>> value[i]>> c[i];
    }
    for (int i = 1; i <= n; i++) {
        multiple_park(value[i], volume[i], c[i]);
    }
    cout<< dp[v]<< endl;
    return 0;
}
```

## 小结

这里我们看到了将一个算法的复杂度由$O(V*∑n[i])$改进到$O(V*∑log n[i])$的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。

## 练习

1. [acwing模板题——多重背包问题 I](https://www.acwing.com/problem/content/4/)
2. [acwing模板题——多重背包问题 II](https://www.acwing.com/problem/content/5/)：本题考查多重背包的二进制优化方法。

# P04: 混合三种背包问题

## 题目

如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？

## 01背包与完全背包的混合

考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是$O(VN)$。伪代码如下：

```c++
for i=1..N
	if 第i件物品是01背包
		for v=V..0
			f[v]=max{f[v],f[v-c[i]]+w[i]};
	else if 第i件物品是完全背包
		for v=0..V
			f[v]=max{f[v],f[v-c[i]]+w[i]};
```

## 再加上多重背包

如果再加上有的物品最多可以取有限次，那么原则上也可以给出$O(VN)$的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成$O(log n[i])$个01背包的物品的方法也已经很优了。

## 小结

有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。

## 练习

1. [acwing模板题——混合背包问题](acwing.com/problem/content/7/)

# P05: 二维费用的背包问题

## 题目

二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为$a[i]$和$b[i]$。两种代价可付出的最大值（两种背包容量）分别为$V$和$U$。物品的价值为$w[i]$。

## 算法

费用加了一维，只需状态也加一维即可。设$f[i][v][u]$表示前$i$件物品付出两种代价分别为$v$和$u$时可获得的最大价值。状态转移方程就是：$f [i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}$。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量$v$和$u$采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。

## 物品总个数的限制

有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取$M$件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为$1$，可以付出的最大件数费用为$M$。换句话说，设$f[v][m]$表示付出费用$v$、最多选$m$件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在$f[0..V][0..M]$范围内寻找答案。

另外，如果要求“恰取M件物品”，则在$f[0..V][M]$范围内寻找答案。

## 代码实现

```C++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 5;//物品最大数量
const int maxv = 1e2 + 5;//背包最大体积
const int maxw = 1e2 + 5;//背包最大承受重量

int dp[maxv][maxw];//背包
int volume[maxn], value[maxn], weight[maxn];//每个物品的体积和价值、重量
int n, v, w;//总物品数、背包体积、背包承受重量
//二维01背包
void two_dimension_park(int val, int wei, int vol) {
    for (int j = v; j >= vol; j--) {
        for (int k = w; k >= wei; k--) {
            dp[j][k] = max(dp[j][k], dp[j - vol][k - wei] + val);
        }
    }
}

int main() {
    cin>> n>> v>> w;
    for (int i = 1; i <= n; i++) {
        cin>> volume[i]>> weight[i]>> value[i];
    }
    for (int i = 1; i <= n; i++) {
        two_dimension_park(value[i], weight[i],volume[i]);
    }
    cout<< dp[v][w]<< endl;
    return 0;
}
```

## 小结

事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一维以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。

## 练习

1. [acwing模板题——二维费用的背包问题](https://www.acwing.com/problem/content/8/)

# P06: 分组背包问题

## 题目

有$N$件物品和一个容量为$V$的背包。第$i$件物品的费用是$c[i]$，价值是$w[i]$。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

## 算法

这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设$f[k][v]$表示前$k$组物品花费费用$v$能取得的最大权值，则有$f[k][v]=max\{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组\}$。

使用一维数组的伪代码如下：

```c++
for 所有的组k
    for v=V..0
        for 所有的i属于组k
            f[v]=max{f[v],f[v-c[i]]+w[i]}
```

注意这里的三层循环的顺序，“for v=V..0”这一层循环必须在“for 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。

另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。

## 代码实现

```C++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e2 + 5;//物品最大数量
const int maxv = 1e2 + 5;//背包最大体积

int dp[maxv];//背包
int volume[maxn], value[maxn];//每个物品的体积和价值
int n, v;//物品组数、背包体积
//分组背包 物品被划分为若干组，每组最多选一件
void group_park(int n, int vol) {//物品组数、背包最大容量
    for (int k = 1; k <= n; k++) {
        int t;//每组的个数
        cin>> t;
        for (int i = 1; i <= t; i++) {
            cin>> volume[i]>> value[i];
        }
        //从前k组中选
        for (int j = vol; j >= 0; j--) {
            for (int l = 1; l <= t; l++) {
                if (volume[l] <= j) {
                    dp[j] = max(dp[j], dp[j - volume[l]] + value[l]);
                }
            }
        }
    }

}

int main() {
    cin>> n>> v;
    group_park(n, v);
    cout<< dp[v]<< endl;
    return 0;
}
```

## 小结

分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。

## 练习

1. [acwing模板题——分组背包问题](acwing.com/problem/content/9/)
2. [牛客——xinjun与阴阳师](https://ac.nowcoder.com/acm/problem/14602)

# * P07: 有依赖的背包问题

## 简化的问题

这种背包问题的物品间存在某种“依赖”的关系。也就是说，$i$依赖于$j$，表示若选物品$i$，则必须选物品$j$。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。

## 算法

这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。

按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有$n$个附件，则策略有$2^n+1$个，为指数级）

考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于 P06 中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。

再考虑P06中的一句话： *可以对每组中的物品应用P02中“一个简单有效的优化”*。 这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件$i$的“附件集合”先进行一次01背包，得到费用依次为$0..V-c[i]$所有这些值时相应的最大价值$f'[0..V-c[i]]$。那么这个主件及它的附件集合相当于$V-c[i]+1$个物品的物品组，其中费用为$c[i]+k$的物品的价值为$f'[k]+w[i]$。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件$i$转化为$V-c[i]+1$个物品的物品组，就可以直接应用P06的算法解决问题了。

## 较一般的问题

更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。

解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。

事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。

## 具体思路

dfs在遍历到 $x$ 结点时，先考虑一定选上根节点 $x$ ，因此初始化 $f[x][v[x]...m] = w[x]$
在分组背包部分：
$j$ 的范围 $[ m , v[x] ] $小于$v[x]$则没有意义因为连根结点都放不下；
$k$的范围$ [ 0 , j-v[x] ]$，当大于$j-v[x]$时分给该子树的容量过多，剩余的容量连根节点的物品都放不下了；

## 代码实现

```C++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 5;//物品最大数量
const int maxv = 1e2 + 5;//背包最大体积

int dp[maxn][maxv];//dp[x][v]表达选择以x为子树的物品，在容量不超过v时所获得的最大价值
vector<int> tree[maxn];//树，存放依赖关系
int volume[maxn], value[maxn];//每个物品的体积和价值
int n, v, root;//总物品数、背包容量、树根结点
//有依赖的背包
void dfs(int x) {
    for (int i = volume[x]; i <= v; i++) dp[x][i] = value[x];//点x必须选，所以初始化dp[x][value[x] ~ v]= value[x]
    for (int i = 0; i < tree[x].size(); i++) {
        int son = tree[x][i];
        dfs(son);
        for (int j = v; j >= volume[x]; j--) {//j的范围为value[x]~v, 小于value[x]无法选择以x为子树的物品
            for (int k = 0; k <= j - volume[x]; k++) {//分给子树son的空间不能大于j-value[x],不然都无法选根物品x
                dp[x][j] = max(dp[x][j], dp[x][j - k] + dp[son][k]);
            }
        }
    }
}

int main() {
    cin>> n>> v;
    for (int i = 1; i <= n; i++) {
        int fa;
        cin>> volume[i]>> value[i]>> fa;
        if (fa == -1)
            root = i;
        else
            tree[fa].push_back(i);
    }
    dfs(root);
    cout<< dp[root][v];
    return 0;
}
```

## 小结

NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。

我想说：失败不是什么丢人的事情，从失败中全无收获才是。

## 练习

1. [acwing模板题——有依赖的背包问题](https://www.acwing.com/problem/content/10/)

# * P08: 泛化物品

## 题目

## 算法

## 代码实现

```C++

```

## 小结



## 练习



# P09: 背包问题问法的变化

## 输出方案

## 输出字典序最小的最优方案

这里“字典序最小”的意思是$1...N$号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。

题目要求输出字典序最小的解，假设存在一个包含第1个物品的最优解，为了确保字典序最小那么我们必然要选第一个。那么问题就转化成从$2～N$这些物品中找到最优解。之前的$f(i,j)$记录的都是前$i$个物品总容量为$j$的最优解，那么我们现在将$f(i,j)$定义为从第$i$个元素到最后一个元素总容量为$j$的最优解。接下来考虑状态转移：

$f(i,j)=max\{f(i+1,j),f(i+1,j−v[i])+w[i]\}$
两种情况，第一种是不选第$i$个物品，那么最优解等同于从第$i+1$个物品到最后一个元素总容量为$j$的最优解；第二种是选了第$i$个物品，那么最优解等于当前物品的价值$w[i]$加上从第$i+1$个物品到最后一个元素总容量为$j−v[i]$的最优解。

计算完状态表示后，考虑如何的到最小字典序的解。首先$f(1,m)$肯定是最大价值，那么我们便开始考虑能否选取第1个物品呢。

如果$f(1,m)=f(2,m−v[1])+w[1]$，说明选取了第1个物品可以得到最优解。

如果$f(1,m)=f(2,m)$，说明不选取第一个物品才能得到最优解。

如果$f(1,m)=f(2,m)=f(2,m−v[1])+w[1]$，说明选不选都可以得到最优解，但是为了考虑字典序最小，我们也需要选取该物品。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 5;//物品最大数量
const int maxv = 1e3 + 5;//背包最大体积

int dp[maxn][maxv];//从第i个元素到最后一个元素总容量为j的最优解
int volume[maxn], value[maxn];//每个物品的体积和价值
int n, v;//总物品数、背包体积
//01背包 每种物品仅有一件，可以选择放或不放
void optimal_park(int val, int vol, int i) {
    for (int j = 0; j <= v; j++) {
        dp[i][j] = dp[i + 1][j];
        if(j >= vol)
            dp[i][j] = max(dp[i][j], dp[i + 1][j - vol] + val);
    }
}
int main() {
    cin>> n>> v;
    for (int i = 1; i <= n; i++) {
        cin>> volume[i]>> value[i];
    }
    for (int i = n; i >= 1; i--) {
        optimal_park(value[i], volume[i], i);
    }
    //输出
    int cur_v = v;
    for (int i = 1 ; i <= n ; i++) {   
        if (i == n && cur_v >= volume[i]) {//如果是最后一个元素，特判一下，防止越界即可
            cout<< i;
            break;
        }
        if (cur_v <= 0)
            break;
        //判断下标是否越界
        if (cur_v - volume[i]>=0 && dp[i][cur_v] == dp[i + 1][cur_v - volume[i]] + value[i]) {
            cout<< i<< " ";
            cur_v = cur_v - volume[i];//选了第i个物品，剩余容量就要减小。
        }
    }
    return 0;
}
```

## 求方案总数

## 最优方案的总数

这里的最优方案是指物品总价值最大的方案。以01背包为例。

时间复杂度 $O(nm)$
定义两个数组：$f[maxv]$，$cnt[maxv]$：$f[i]$ 用来存储背包容积为 $i$ 时的最佳方案的总价值，$cnt[i]$为背包容积为 $i$ 时总价值为最佳的方案数。

先初始化所有的 $cnt[i]$ 为 1，因为背包里什么也不装也是一种方案。

外层循环 $n$ 次，每次读入新物品的 $v,w$

求出装新物品时的总价值，与不装新物品时作对比

如果装新物品的方案总价值更大，那么用 $f[j−v]+w$ 来更新 $f[j]$，用 $cnt[j−v]$ 更新 $cnt[j]$
如果总价值相等，那么最大价值的方案数就多了 $cnt[j−v]$ 种。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 5;//物品最大数量
const int maxv = 1e3 + 5;//背包最大体积
const int mod  = 1e9 + 7;

int dp[maxv], cnt[maxv];//背包，最优方案总数
int volume[maxn], value[maxn];//每个物品的体积和价值
int n, v;//总物品数、背包体积
//01背包 求解最优方案总数
void optimal_sum_park(int val, int vol) {
    for (int j = v; j >= vol; j--) {
        int tmp = dp[j - vol] + val;
        if (tmp > dp[j]) {
            dp[j] = tmp;
            cnt[j] = cnt[j - vol];
        } else if (tmp == dp[j]) {
            cnt[j] = (cnt[j] + cnt[j - vol]) % mod;
        }
    }
}
int main() {
    cin>> n>> v;
    for (int i = 1; i <= n; i++) {
        cin>> volume[i]>> value[i];
    }
    for (int i = 0; i <= v; i++) {
        cnt[i] = 1;
    }
    for (int i = 1; i <= n; i++) {
        optimal_sum_park(value[i], volume[i]);
    }
    cout<< cnt[v]<< endl;
    return 0;
}
```

## 小结

显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。

触类旁通、举一反三，应该也是一个OIer应有的品质吧。

## 练习

1. [acwing模板题——背包问题求方案数](https://www.acwing.com/problem/content/11/)
2. []()
